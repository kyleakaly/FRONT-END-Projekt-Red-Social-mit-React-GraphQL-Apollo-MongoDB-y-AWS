{
  "version": 3,
  "sources": ["../../@apollo/src/index.ts", "../../@apollo/src/react/index.ts", "../../@apollo/src/react/context/index.ts", "../../@apollo/src/react/context/ApolloConsumer.tsx", "../../@apollo/src/react/context/ApolloContext.ts", "../../@apollo/src/react/context/ApolloProvider.tsx", "../../@apollo/src/react/hooks/index.ts", "../../@apollo/src/react/hooks/useApolloClient.ts", "../../@apollo/src/react/hooks/useLazyQuery.ts", "../../@apollo/src/react/hooks/useQuery.ts", "../../@apollo/src/react/hooks/useSyncExternalStore.ts", "../../@apollo/src/react/parser/index.ts", "../../@apollo/src/react/hooks/useMutation.ts", "../../@apollo/src/react/hooks/useSubscription.ts", "../../@apollo/src/react/hooks/useReactiveVar.ts"],
  "sourcesContent": ["export * from './core';\nexport * from './react';\n", "import '../utilities/globals';\n\nexport {\n  ApolloProvider,\n  ApolloConsumer,\n  getApolloContext,\n  resetApolloContext,\n  ApolloContextValue\n} from './context';\n\nexport * from './hooks';\n\nexport {\n  DocumentType,\n  IDocumentDefinition,\n  operationName,\n  parser\n} from './parser';\n\nexport * from './types/types';\n", "import '../../utilities/globals';\n\nexport { ApolloConsumer, ApolloConsumerProps } from './ApolloConsumer';\nexport {\n  ApolloContextValue,\n  getApolloContext,\n  getApolloContext as resetApolloContext\n} from './ApolloContext';\nexport { ApolloProvider, ApolloProviderProps } from './ApolloProvider';\n", "import { invariant } from '../../utilities/globals';\n\nimport * as React from 'react';\n\nimport { ApolloClient } from '../../core';\nimport { getApolloContext } from './ApolloContext';\n\nexport interface ApolloConsumerProps {\n  children: (client: ApolloClient<object>) => React.ReactChild | null;\n}\n\nexport const ApolloConsumer: React.FC<ApolloConsumerProps> = props => {\n  const ApolloContext = getApolloContext();\n  return (\n    <ApolloContext.Consumer>\n      {(context: any) => {\n        invariant(\n          context && context.client,\n          'Could not find \"client\" in the context of ApolloConsumer. ' +\n            'Wrap the root component in an <ApolloProvider>.'\n        );\n        return props.children(context.client);\n      }}\n    </ApolloContext.Consumer>\n  );\n};\n", "import * as React from 'react';\nimport { ApolloClient } from '../../core';\nimport { canUseSymbol } from '../../utilities';\nimport type { RenderPromises } from '../ssr';\n\nexport interface ApolloContextValue {\n  client?: ApolloClient<object>;\n  renderPromises?: RenderPromises;\n}\n\n// To make sure Apollo Client doesn't create more than one React context\n// (which can lead to problems like having an Apollo Client instance added\n// in one context, then attempting to retrieve it from another different\n// context), a single Apollo context is created and tracked in global state.\nconst contextKey = canUseSymbol\n  ? Symbol.for('__APOLLO_CONTEXT__')\n  : '__APOLLO_CONTEXT__';\n\nexport function getApolloContext(): React.Context<ApolloContextValue> {\n  let context = (React.createContext as any)[contextKey] as React.Context<ApolloContextValue>;\n  if (!context) {\n    Object.defineProperty(React.createContext, contextKey, {\n      value: context = React.createContext<ApolloContextValue>({}),\n      enumerable: false,\n      writable: false,\n      configurable: true,\n    });\n    context.displayName = 'ApolloContext';\n  }\n  return context;\n}\n\nexport { getApolloContext as resetApolloContext }\n", "import { invariant } from '../../utilities/globals';\n\nimport * as React from 'react';\n\nimport { ApolloClient } from '../../core';\nimport { getApolloContext } from './ApolloContext';\n\nexport interface ApolloProviderProps<TCache> {\n  client: ApolloClient<TCache>;\n  children: React.ReactNode | React.ReactNode[] | null;\n}\n\nexport const ApolloProvider: React.FC<ApolloProviderProps<any>> = ({\n  client,\n  children\n}) => {\n  const ApolloContext = getApolloContext();\n  return (\n    <ApolloContext.Consumer>\n      {(context: any = {}) => {\n        if (client && context.client !== client) {\n          context = Object.assign({}, context, { client });\n        }\n\n        invariant(\n          context.client,\n          'ApolloProvider was not passed a client instance. Make ' +\n            'sure you pass in your client via the \"client\" prop.'\n        );\n\n        return (\n          <ApolloContext.Provider value={context}>\n            {children}\n          </ApolloContext.Provider>\n        );\n      }}\n    </ApolloContext.Consumer>\n  );\n};\n", "import '../../utilities/globals';\n\nexport * from './useApolloClient';\nexport * from './useLazyQuery';\nexport * from './useMutation';\nexport { useQuery } from './useQuery';\nexport * from './useSubscription';\nexport * from './useReactiveVar';\n", "import { invariant } from '../../utilities/globals';\nimport { useContext } from 'react';\nimport { ApolloClient } from '../../core';\nimport { getApolloContext } from '../context';\n\nexport function useApolloClient(\n  override?: ApolloClient<object>,\n): ApolloClient<object> {\n  const context = useContext(getApolloContext());\n  const client = override || context.client;\n  invariant(\n    !!client,\n    'Could not find \"client\" in the context or passed in as an option. ' +\n    'Wrap the root component in an <ApolloProvider>, or pass an ApolloClient ' +\n    'instance in via options.',\n  );\n\n  return client;\n}\n", "import { DocumentNode } from 'graphql';\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\nimport { useCallback, useMemo, useRef } from 'react';\n\nimport { OperationVariables } from '../../core';\nimport { mergeOptions } from '../../utilities';\nimport {\n  LazyQueryHookOptions,\n  LazyQueryResultTuple,\n  QueryResult,\n} from '../types/types';\nimport { useInternalState } from './useQuery';\nimport { useApolloClient } from './useApolloClient';\n\n// The following methods, when called will execute the query, regardless of\n// whether the useLazyQuery execute function was called before.\nconst EAGER_METHODS = [\n  'refetch',\n  'reobserve',\n  'fetchMore',\n  'updateQuery',\n  'startPolling',\n  'subscribeToMore',\n] as const;\n\nexport function useLazyQuery<TData = any, TVariables = OperationVariables>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: LazyQueryHookOptions<TData, TVariables>\n): LazyQueryResultTuple<TData, TVariables> {\n  const internalState = useInternalState(\n    useApolloClient(options && options.client),\n    query,\n  );\n\n  const execOptionsRef = useRef<Partial<LazyQueryHookOptions<TData, TVariables>>>();\n  const merged = execOptionsRef.current\n    ? mergeOptions(options, execOptionsRef.current)\n    : options;\n\n  const useQueryResult = internalState.useQuery({\n    ...merged,\n    skip: !execOptionsRef.current,\n  });\n\n  const initialFetchPolicy =\n    useQueryResult.observable.options.initialFetchPolicy ||\n    internalState.getDefaultFetchPolicy();\n\n  const result: QueryResult<TData, TVariables> =\n    Object.assign(useQueryResult, {\n      called: !!execOptionsRef.current,\n    });\n\n  // We use useMemo here to make sure the eager methods have a stable identity.\n  const eagerMethods = useMemo(() => {\n    const eagerMethods: Record<string, any> = {};\n    for (const key of EAGER_METHODS) {\n      const method = result[key];\n      eagerMethods[key] = function () {\n        if (!execOptionsRef.current) {\n          execOptionsRef.current = Object.create(null);\n          // Only the first time populating execOptionsRef.current matters here.\n          internalState.forceUpdate();\n        }\n        return method.apply(this, arguments);\n      };\n    }\n\n    return eagerMethods;\n  }, []);\n\n  Object.assign(result, eagerMethods);\n\n  const execute = useCallback<\n    LazyQueryResultTuple<TData, TVariables>[0]\n  >(executeOptions => {\n    execOptionsRef.current = executeOptions ? {\n      ...executeOptions,\n      fetchPolicy: executeOptions.fetchPolicy || initialFetchPolicy,\n    } : {\n      fetchPolicy: initialFetchPolicy,\n    };\n\n    const promise = internalState\n      .asyncUpdate() // Like internalState.forceUpdate, but returns a Promise.\n      .then(queryResult => Object.assign(queryResult, eagerMethods));\n\n    // Because the return value of `useLazyQuery` is usually floated, we need\n    // to catch the promise to prevent unhandled rejections.\n    promise.catch(() => {});\n\n    return promise;\n  }, []);\n\n  return [execute, result];\n}\n", "import { invariant } from '../../utilities/globals';\n\nimport {\n  useCallback,\n  useContext,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport { useSyncExternalStore } from './useSyncExternalStore';\nimport { equal } from '@wry/equality';\n\nimport { mergeOptions, OperationVariables, WatchQueryFetchPolicy } from '../../core';\nimport { ApolloContextValue, getApolloContext } from '../context';\nimport { ApolloError } from '../../errors';\nimport {\n  ApolloClient,\n  ApolloQueryResult,\n  NetworkStatus,\n  ObservableQuery,\n  DocumentNode,\n  TypedDocumentNode,\n  WatchQueryOptions,\n} from '../../core';\nimport {\n  QueryHookOptions,\n  QueryResult,\n  ObservableQueryFields,\n} from '../types/types';\n\nimport { DocumentType, verifyDocumentType } from '../parser';\nimport { useApolloClient } from './useApolloClient';\nimport { canUseWeakMap, canUseWeakSet, compact, isNonEmptyArray, maybeDeepFreeze } from '../../utilities';\n\nconst {\n  prototype: {\n    hasOwnProperty,\n  },\n} = Object;\n\nexport function useQuery<\n  TData = any,\n  TVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: QueryHookOptions<TData, TVariables> = Object.create(null),\n): QueryResult<TData, TVariables> {\n  return useInternalState(\n    useApolloClient(options.client),\n    query,\n  ).useQuery(options);\n}\n\nexport function useInternalState<TData, TVariables>(\n  client: ApolloClient<any>,\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n): InternalState<TData, TVariables> {\n  const stateRef = useRef<InternalState<TData, TVariables>>();\n  if (\n    !stateRef.current ||\n    client !== stateRef.current.client ||\n    query !== stateRef.current.query\n  ) {\n    stateRef.current = new InternalState(client, query, stateRef.current);\n  }\n  const state = stateRef.current;\n\n  // By default, InternalState.prototype.forceUpdate is an empty function, but\n  // we replace it here (before anyone has had a chance to see this state yet)\n  // with a function that unconditionally forces an update, using the latest\n  // setTick function. Updating this state by calling state.forceUpdate is the\n  // only way we trigger React component updates (no other useState calls within\n  // the InternalState class).\n  const [_tick, setTick] = useState(0);\n  state.forceUpdate = () => {\n    setTick(tick => tick + 1);\n  };\n\n  return state;\n}\n\nclass InternalState<TData, TVariables> {\n  constructor(\n    public readonly client: ReturnType<typeof useApolloClient>,\n    public readonly query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    previous?: InternalState<TData, TVariables>,\n  ) {\n    verifyDocumentType(query, DocumentType.Query);\n\n    // Reuse previousData from previous InternalState (if any) to provide\n    // continuity of previousData even if/when the query or client changes.\n    const previousResult = previous && previous.result;\n    const previousData = previousResult && previousResult.data;\n    if (previousData) {\n      this.previousData = previousData;\n    }\n  }\n\n  forceUpdate() {\n    // Replaced (in useInternalState) with a method that triggers an update.\n    invariant.warn(\"Calling default no-op implementation of InternalState#forceUpdate\");\n  }\n\n  asyncUpdate() {\n    return new Promise<QueryResult<TData, TVariables>>(resolve => {\n      this.asyncResolveFns.add(resolve);\n      this.optionsToIgnoreOnce.add(this.watchQueryOptions);\n      this.forceUpdate();\n    });\n  }\n\n  private asyncResolveFns = new Set<\n    (result: QueryResult<TData, TVariables>) => void\n  >();\n\n  private optionsToIgnoreOnce = new (canUseWeakSet ? WeakSet : Set)<\n    WatchQueryOptions<TVariables, TData>\n  >();\n\n  // Methods beginning with use- should be called according to the standard\n  // rules of React hooks: only at the top level of the calling function, and\n  // without any dynamic conditional logic.\n  useQuery(options: QueryHookOptions<TData, TVariables>) {\n    // The renderPromises field gets initialized here in the useQuery method, at\n    // the beginning of everything (for a given component rendering, at least),\n    // so we can safely use this.renderPromises in other/later InternalState\n    // methods without worrying it might be uninitialized. Even after\n    // initialization, this.renderPromises is usually undefined (unless SSR is\n    // happening), but that's fine as long as it has been initialized that way,\n    // rather than left uninitialized.\n    this.renderPromises = useContext(getApolloContext()).renderPromises;\n\n    this.useOptions(options);\n\n    const obsQuery = this.useObservableQuery();\n\n    const result = useSyncExternalStore(\n      useCallback(() => {\n        if (this.renderPromises) {\n          return () => {};\n        }\n\n        const onNext = () => {\n          const previousResult = this.result;\n          // We use `getCurrentResult()` instead of the onNext argument because\n          // the values differ slightly. Specifically, loading results will have\n          // an empty object for data instead of `undefined` for some reason.\n          const result = obsQuery.getCurrentResult();\n          // Make sure we're not attempting to re-render similar results\n          if (\n            previousResult &&\n            previousResult.loading === result.loading &&\n            previousResult.networkStatus === result.networkStatus &&\n            equal(previousResult.data, result.data)\n          ) {\n            return;\n          }\n\n          this.setResult(result);\n        };\n\n        const onError = (error: Error) => {\n          const last = obsQuery[\"last\"];\n          subscription.unsubscribe();\n          // Unfortunately, if `lastError` is set in the current\n          // `observableQuery` when the subscription is re-created,\n          // the subscription will immediately receive the error, which will\n          // cause it to terminate again. To avoid this, we first clear\n          // the last error/result from the `observableQuery` before re-starting\n          // the subscription, and restore it afterwards (so the subscription\n          // has a chance to stay open).\n          try {\n            obsQuery.resetLastResults();\n            subscription = obsQuery.subscribe(onNext, onError);\n          } finally {\n            obsQuery[\"last\"] = last;\n          }\n\n          if (!hasOwnProperty.call(error, 'graphQLErrors')) {\n            // The error is not a GraphQL error\n            throw error;\n          }\n\n          const previousResult = this.result;\n          if (\n            !previousResult ||\n            (previousResult && previousResult.loading) ||\n            !equal(error, previousResult.error)\n          ) {\n            this.setResult({\n              data: (previousResult && previousResult.data) as TData,\n              error: error as ApolloError,\n              loading: false,\n              networkStatus: NetworkStatus.error,\n            });\n          }\n        };\n\n        let subscription = obsQuery.subscribe(onNext, onError);\n\n        return () => subscription.unsubscribe();\n      }, [\n        // We memoize the subscribe function using useCallback and the following\n        // dependency keys, because the subscribe function reference is all that\n        // useSyncExternalStore uses internally as a dependency key for the\n        // useEffect ultimately responsible for the subscription, so we are\n        // effectively passing this dependency array to that useEffect buried\n        // inside useSyncExternalStore, as desired.\n        obsQuery,\n        this.renderPromises,\n        this.client.disableNetworkFetches,\n      ]),\n\n      () => this.getCurrentResult(),\n      () => this.getCurrentResult(),\n    );\n\n    // TODO Remove this method when we remove support for options.partialRefetch.\n    this.unsafeHandlePartialRefetch(result);\n\n    const queryResult = this.toQueryResult(result);\n\n    if (!queryResult.loading && this.asyncResolveFns.size) {\n      this.asyncResolveFns.forEach(resolve => resolve(queryResult));\n      this.asyncResolveFns.clear();\n    }\n\n    return queryResult;\n  }\n\n  // These members (except for renderPromises) are all populated by the\n  // useOptions method, which is called unconditionally at the beginning of the\n  // useQuery method, so we can safely use these members in other/later methods\n  // without worrying they might be uninitialized.\n  private renderPromises: ApolloContextValue[\"renderPromises\"];\n  private queryHookOptions: QueryHookOptions<TData, TVariables>;\n  private watchQueryOptions: WatchQueryOptions<TVariables, TData>;\n\n  private useOptions(\n    options: QueryHookOptions<TData, TVariables>,\n  ) {\n    const watchQueryOptions = this.createWatchQueryOptions(\n      this.queryHookOptions = options,\n    );\n\n    // Update this.watchQueryOptions, but only when they have changed, which\n    // allows us to depend on the referential stability of\n    // this.watchQueryOptions elsewhere.\n    const currentWatchQueryOptions = this.watchQueryOptions;\n\n    // To force this equality test to \"fail,\" thereby reliably triggering\n    // observable.reobserve, add any current WatchQueryOptions object(s) you\n    // want to be ignored to this.optionsToIgnoreOnce. A similar effect could be\n    // achieved by nullifying this.watchQueryOptions so the equality test\n    // immediately fails because currentWatchQueryOptions is null, but this way\n    // we can promise a truthy this.watchQueryOptions at all times.\n    if (\n      this.optionsToIgnoreOnce.has(currentWatchQueryOptions) ||\n      !equal(watchQueryOptions, currentWatchQueryOptions)\n    ) {\n      this.watchQueryOptions = watchQueryOptions;\n\n      if (currentWatchQueryOptions && this.observable) {\n        // As advertised in the -Once of this.optionsToIgnoreOnce, this trick is\n        // only good for one forced execution of observable.reobserve per\n        // ignored WatchQueryOptions object, though it is unlikely we will ever\n        // see this exact currentWatchQueryOptions object again here, since we\n        // just replaced this.watchQueryOptions with watchQueryOptions.\n        this.optionsToIgnoreOnce.delete(currentWatchQueryOptions);\n\n        // Though it might be tempting to postpone this reobserve call to the\n        // useEffect block, we need getCurrentResult to return an appropriate\n        // loading:true result synchronously (later within the same call to\n        // useQuery). Since we already have this.observable here (not true for\n        // the very first call to useQuery), we are not initiating any new\n        // subscriptions, though it does feel less than ideal that reobserve\n        // (potentially) kicks off a network request (for example, when the\n        // variables have changed), which is technically a side-effect.\n        this.observable.reobserve(this.getObsQueryOptions());\n\n        // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n        // but save the current data as this.previousData, just like setResult\n        // usually does.\n        this.previousData = this.result?.data || this.previousData;\n        this.result = void 0;\n      }\n    }\n\n    // Make sure state.onCompleted and state.onError always reflect the latest\n    // options.onCompleted and options.onError callbacks provided to useQuery,\n    // since those functions are often recreated every time useQuery is called.\n    // Like the forceUpdate method, the versions of these methods inherited from\n    // InternalState.prototype are empty no-ops, but we can override them on the\n    // base state object (without modifying the prototype).\n    this.onCompleted = options.onCompleted || InternalState.prototype.onCompleted;\n    this.onError = options.onError || InternalState.prototype.onError;\n\n    if (\n      (this.renderPromises || this.client.disableNetworkFetches) &&\n      this.queryHookOptions.ssr === false &&\n      !this.queryHookOptions.skip\n    ) {\n      // If SSR has been explicitly disabled, and this function has been called\n      // on the server side, return the default loading state.\n      this.result = this.ssrDisabledResult;\n    } else if (\n      this.queryHookOptions.skip ||\n      this.watchQueryOptions.fetchPolicy === 'standby'\n    ) {\n      // When skipping a query (ie. we're not querying for data but still want to\n      // render children), make sure the `data` is cleared out and `loading` is\n      // set to `false` (since we aren't loading anything).\n      //\n      // NOTE: We no longer think this is the correct behavior. Skipping should\n      // not automatically set `data` to `undefined`, but instead leave the\n      // previous data in place. In other words, skipping should not mandate that\n      // previously received data is all of a sudden removed. Unfortunately,\n      // changing this is breaking, so we'll have to wait until Apollo Client 4.0\n      // to address this.\n      this.result = this.skipStandbyResult;\n    } else if (\n      this.result === this.ssrDisabledResult ||\n      this.result === this.skipStandbyResult\n    ) {\n      this.result = void 0;\n    }\n  }\n\n  private getObsQueryOptions(): WatchQueryOptions<TVariables, TData> {\n    const toMerge: Array<\n      Partial<WatchQueryOptions<TVariables, TData>>\n    > = [];\n\n    const globalDefaults = this.client.defaultOptions.watchQuery;\n    if (globalDefaults) toMerge.push(globalDefaults);\n\n    if (this.queryHookOptions.defaultOptions) {\n      toMerge.push(this.queryHookOptions.defaultOptions);\n    }\n\n    // We use compact rather than mergeOptions for this part of the merge,\n    // because we want watchQueryOptions.variables (if defined) to replace\n    // this.observable.options.variables whole. This replacement allows\n    // removing variables by removing them from the variables input to\n    // useQuery. If the variables were always merged together (rather than\n    // replaced), there would be no way to remove existing variables.\n    // However, the variables from options.defaultOptions and globalDefaults\n    // (if provided) should be merged, to ensure individual defaulted\n    // variables always have values, if not otherwise defined in\n    // observable.options or watchQueryOptions.\n    toMerge.push(compact(\n      this.observable && this.observable.options,\n      this.watchQueryOptions,\n    ));\n\n    return toMerge.reduce(\n      mergeOptions\n    ) as WatchQueryOptions<TVariables, TData>;\n  }\n\n  private ssrDisabledResult = maybeDeepFreeze({\n    loading: true,\n    data: void 0 as unknown as TData,\n    error: void 0,\n    networkStatus: NetworkStatus.loading,\n  });\n\n  private skipStandbyResult = maybeDeepFreeze({\n    loading: false,\n    data: void 0 as unknown as TData,\n    error: void 0,\n    networkStatus: NetworkStatus.ready,\n  });\n\n  // A function to massage options before passing them to ObservableQuery.\n  private createWatchQueryOptions({\n    skip,\n    ssr,\n    onCompleted,\n    onError,\n    displayName,\n    defaultOptions,\n    // The above options are useQuery-specific, so this ...otherOptions spread\n    // makes otherOptions almost a WatchQueryOptions object, except for the\n    // query property that we add below.\n    ...otherOptions\n  }: QueryHookOptions<TData, TVariables> = {}): WatchQueryOptions<TVariables, TData> {\n    // This Object.assign is safe because otherOptions is a fresh ...rest object\n    // that did not exist until just now, so modifications are still allowed.\n    const watchQueryOptions: WatchQueryOptions<TVariables, TData> =\n      Object.assign(otherOptions, { query: this.query });\n\n    if (\n      this.renderPromises &&\n      (\n        watchQueryOptions.fetchPolicy === 'network-only' ||\n        watchQueryOptions.fetchPolicy === 'cache-and-network'\n      )\n    ) {\n      // this behavior was added to react-apollo without explanation in this PR\n      // https://github.com/apollographql/react-apollo/pull/1579\n      watchQueryOptions.fetchPolicy = 'cache-first';\n    }\n\n    if (!watchQueryOptions.variables) {\n      watchQueryOptions.variables = {} as TVariables;\n    }\n\n    if (skip) {\n      const {\n        fetchPolicy = this.getDefaultFetchPolicy(),\n        initialFetchPolicy = fetchPolicy,\n      } = watchQueryOptions;\n\n      // When skipping, we set watchQueryOptions.fetchPolicy initially to\n      // \"standby\", but we also need/want to preserve the initial non-standby\n      // fetchPolicy that would have been used if not skipping.\n      Object.assign(watchQueryOptions, {\n        initialFetchPolicy,\n        fetchPolicy: 'standby',\n      });\n    } else if (!watchQueryOptions.fetchPolicy) {\n      watchQueryOptions.fetchPolicy =\n        this.observable?.options.initialFetchPolicy ||\n        this.getDefaultFetchPolicy();\n    }\n\n    return watchQueryOptions;\n  }\n\n  getDefaultFetchPolicy(): WatchQueryFetchPolicy {\n    return (\n      this.queryHookOptions.defaultOptions?.fetchPolicy ||\n      this.client.defaultOptions.watchQuery?.fetchPolicy ||\n      \"cache-first\"\n    );\n  }\n\n  // Defining these methods as no-ops on the prototype allows us to call\n  // state.onCompleted and/or state.onError without worrying about whether a\n  // callback was provided.\n  private onCompleted(data: TData) {}\n  private onError(error: ApolloError) {}\n\n  private observable: ObservableQuery<TData, TVariables>;\n  private obsQueryFields: Omit<\n    ObservableQueryFields<TData, TVariables>,\n    \"variables\"\n  >;\n\n  private useObservableQuery() {\n    // See if there is an existing observable that was used to fetch the same\n    // data and if so, use it instead since it will contain the proper queryId\n    // to fetch the result set. This is used during SSR.\n    const obsQuery = this.observable =\n      this.renderPromises\n        && this.renderPromises.getSSRObservable(this.watchQueryOptions)\n        || this.observable // Reuse this.observable if possible (and not SSR)\n        || this.client.watchQuery(this.getObsQueryOptions());\n\n    this.obsQueryFields = useMemo(() => ({\n      refetch: obsQuery.refetch.bind(obsQuery),\n      reobserve: obsQuery.reobserve.bind(obsQuery),\n      fetchMore: obsQuery.fetchMore.bind(obsQuery),\n      updateQuery: obsQuery.updateQuery.bind(obsQuery),\n      startPolling: obsQuery.startPolling.bind(obsQuery),\n      stopPolling: obsQuery.stopPolling.bind(obsQuery),\n      subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery),\n    }), [obsQuery]);\n\n    const ssrAllowed = !(\n      this.queryHookOptions.ssr === false ||\n      this.queryHookOptions.skip\n    );\n\n    if (this.renderPromises && ssrAllowed) {\n      this.renderPromises.registerSSRObservable(obsQuery);\n\n      if (obsQuery.getCurrentResult().loading) {\n        // TODO: This is a legacy API which could probably be cleaned up\n        this.renderPromises.addObservableQueryPromise(obsQuery);\n      }\n    }\n\n    return obsQuery;\n  }\n\n  // These members are populated by getCurrentResult and setResult, and it's\n  // okay/normal for them to be initially undefined.\n  private result: undefined | ApolloQueryResult<TData>;\n  private previousData: undefined | TData;\n\n  private setResult(nextResult: ApolloQueryResult<TData>) {\n    const previousResult = this.result;\n    if (previousResult && previousResult.data) {\n      this.previousData = previousResult.data;\n    }\n    this.result = nextResult;\n    // Calling state.setResult always triggers an update, though some call sites\n    // perform additional equality checks before committing to an update.\n    this.forceUpdate();\n    this.handleErrorOrCompleted(nextResult);\n  }\n\n  private handleErrorOrCompleted(result: ApolloQueryResult<TData>) {\n    if (!result.loading) {\n      if (result.error) {\n        this.onError(result.error);\n      } else if (result.data) {\n        this.onCompleted(result.data);\n      }\n    }\n  }\n\n  private getCurrentResult(): ApolloQueryResult<TData> {\n    // Using this.result as a cache ensures getCurrentResult continues returning\n    // the same (===) result object, unless state.setResult has been called, or\n    // we're doing server rendering and therefore override the result below.\n    if (!this.result) {\n      this.handleErrorOrCompleted(\n        this.result = this.observable.getCurrentResult()\n      );\n    }\n    return this.result;\n  }\n\n  // This cache allows the referential stability of this.result (as returned by\n  // getCurrentResult) to translate into referential stability of the resulting\n  // QueryResult object returned by toQueryResult.\n  private toQueryResultCache = new (canUseWeakMap ? WeakMap : Map)<\n    ApolloQueryResult<TData>,\n    QueryResult<TData, TVariables>\n  >();\n\n  toQueryResult(\n    result: ApolloQueryResult<TData>,\n  ): QueryResult<TData, TVariables> {\n    let queryResult = this.toQueryResultCache.get(result);\n    if (queryResult) return queryResult;\n\n    const { data, partial, ...resultWithoutPartial } = result;\n    this.toQueryResultCache.set(result, queryResult = {\n      data, // Ensure always defined, even if result.data is missing.\n      ...resultWithoutPartial,\n      ...this.obsQueryFields,\n      client: this.client,\n      observable: this.observable,\n      variables: this.observable.variables,\n      called: !this.queryHookOptions.skip,\n      previousData: this.previousData,\n    });\n\n    if (!queryResult.error && isNonEmptyArray(result.errors)) {\n      // Until a set naming convention for networkError and graphQLErrors is\n      // decided upon, we map errors (graphQLErrors) to the error options.\n      // TODO: Is it possible for both result.error and result.errors to be\n      // defined here?\n      queryResult.error = new ApolloError({ graphQLErrors: result.errors });\n    }\n\n    return queryResult;\n  }\n\n  private unsafeHandlePartialRefetch(result: ApolloQueryResult<TData>) {\n    // WARNING: SIDE-EFFECTS IN THE RENDER FUNCTION\n    //\n    // TODO: This code should be removed when the partialRefetch option is\n    // removed. I was unable to get this hook to behave reasonably in certain\n    // edge cases when this block was put in an effect.\n    if (\n      result.partial &&\n      this.queryHookOptions.partialRefetch &&\n      !result.loading &&\n      (!result.data || Object.keys(result.data).length === 0) &&\n      this.observable.options.fetchPolicy !== 'cache-only'\n    ) {\n      Object.assign(result, {\n        loading: true,\n        networkStatus: NetworkStatus.refetch,\n      });\n      this.observable.refetch();\n    }\n  }\n}\n", "import { invariant } from '../../utilities/globals';\nimport * as React from 'react';\n\nimport { canUseLayoutEffect } from '../../utilities';\n\nlet didWarnUncachedGetSnapshot = false;\n\ntype RealUseSESHookType =\n  // This import depends only on the @types/use-sync-external-store package, not\n  // the actual use-sync-external-store package, which is not installed. It\n  // might be nice to get this type from React 18, but it still needs to work\n  // when only React 17 or earlier is installed.\n  typeof import(\"use-sync-external-store\").useSyncExternalStore;\n\n// Prevent webpack from complaining about our feature detection of the\n// useSyncExternalStore property of the React namespace, which is expected not\n// to exist when using React 17 and earlier, and that's fine.\nconst uSESKey = \"useSyncExternalStore\" as keyof typeof React;\nconst realHook = React[uSESKey] as RealUseSESHookType | undefined;\n\n// Adapted from https://www.npmjs.com/package/use-sync-external-store, with\n// Apollo Client deviations called out by \"// DEVIATION ...\" comments.\n\n// When/if React.useSyncExternalStore is defined, delegate fully to it.\nexport const useSyncExternalStore: RealUseSESHookType = realHook || ((\n  subscribe,\n  getSnapshot,\n  getServerSnapshot,\n) => {\n  // Read the current snapshot from the store on every render. Again, this\n  // breaks the rules of React, and only works here because of specific\n  // implementation details, most importantly that updates are\n  // always synchronous.\n  const value = getSnapshot();\n  if (\n    // DEVIATION: Using our own __DEV__ polyfill (from ../../utilities/globals).\n    __DEV__ &&\n    !didWarnUncachedGetSnapshot &&\n    // DEVIATION: Not using Object.is because we know our snapshots will never\n    // be exotic primitive values like NaN, which is !== itself.\n    value !== getSnapshot()\n  ) {\n    didWarnUncachedGetSnapshot = true;\n    // DEVIATION: Using invariant.error instead of console.error directly.\n    invariant.error(\n      'The result of getSnapshot should be cached to avoid an infinite loop',\n    );\n  }\n\n  // Because updates are synchronous, we don't queue them. Instead we force a\n  // re-render whenever the subscribed state changes by updating an some\n  // arbitrary useState hook. Then, during render, we call getSnapshot to read\n  // the current value.\n  //\n  // Because we don't actually use the state returned by the useState hook, we\n  // can save a bit of memory by storing other stuff in that slot.\n  //\n  // To implement the early bailout, we need to track some things on a mutable\n  // object. Usually, we would put that in a useRef hook, but we can stash it in\n  // our useState hook instead.\n  //\n  // To force a re-render, we call forceUpdate({inst}). That works because the\n  // new object always fails an equality check.\n  const [{inst}, forceUpdate] = React.useState({inst: {value, getSnapshot}});\n\n  // Track the latest getSnapshot function with a ref. This needs to be updated\n  // in the layout phase so we can access it during the tearing check that\n  // happens on subscribe.\n  if (canUseLayoutEffect) {\n    // DEVIATION: We avoid calling useLayoutEffect when !canUseLayoutEffect,\n    // which may seem like a conditional hook, but this code ends up behaving\n    // unconditionally (one way or the other) because canUseLayoutEffect is\n    // constant.\n    React.useLayoutEffect(() => {\n      Object.assign(inst, { value, getSnapshot });\n      // Whenever getSnapshot or subscribe changes, we need to check in the\n      // commit phase if there was an interleaved mutation. In concurrent mode\n      // this can happen all the time, but even in synchronous mode, an earlier\n      // effect may have mutated the store.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({inst});\n      }\n    }, [subscribe, value, getSnapshot]);\n  } else {\n    Object.assign(inst, { value, getSnapshot });\n  }\n\n  React.useEffect(() => {\n    // Check for changes right before subscribing. Subsequent changes will be\n    // detected in the subscription handler.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({inst});\n    }\n\n    // Subscribe to the store and return a clean-up function.\n    return subscribe(function handleStoreChange() {\n      // TODO: Because there is no cross-renderer API for batching updates, it's\n      // up to the consumer of this library to wrap their subscription event\n      // with unstable_batchedUpdates. Should we try to detect when this isn't\n      // the case and print a warning in development?\n\n      // The store changed. Check if the snapshot changed since the last time we\n      // read from the store.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({inst});\n      }\n    });\n  }, [subscribe]);\n\n  return value;\n});\n\nfunction checkIfSnapshotChanged<Snapshot>({\n  value,\n  getSnapshot,\n}: {\n  value: Snapshot;\n  getSnapshot: () => Snapshot;\n}): boolean {\n  try {\n    return value !== getSnapshot();\n  } catch {\n    return true;\n  }\n}\n", "import { invariant } from '../../utilities/globals';\n\nimport {\n  DocumentNode,\n  DefinitionNode,\n  VariableDefinitionNode,\n  OperationDefinitionNode\n} from 'graphql';\n\nexport enum DocumentType {\n  Query,\n  Mutation,\n  Subscription\n}\n\nexport interface IDocumentDefinition {\n  type: DocumentType;\n  name: string;\n  variables: ReadonlyArray<VariableDefinitionNode>;\n}\n\nconst cache = new Map();\n\nexport function operationName(type: DocumentType) {\n  let name;\n  switch (type) {\n    case DocumentType.Query:\n      name = 'Query';\n      break;\n    case DocumentType.Mutation:\n      name = 'Mutation';\n      break;\n    case DocumentType.Subscription:\n      name = 'Subscription';\n      break;\n  }\n  return name;\n}\n\n// This parser is mostly used to safety check incoming documents.\nexport function parser(document: DocumentNode): IDocumentDefinition {\n  const cached = cache.get(document);\n  if (cached) return cached;\n\n  let variables, type, name;\n\n  invariant(\n    !!document && !!document.kind,\n    `Argument of ${document} passed to parser was not a valid GraphQL ` +\n      `DocumentNode. You may need to use 'graphql-tag' or another method ` +\n      `to convert your operation into a document`\n  );\n\n  const fragments: DefinitionNode[] = []\n  const queries: DefinitionNode[] = []\n  const mutations: DefinitionNode[] = []\n  const subscriptions: DefinitionNode[] = []\n\n  for (const x of document.definitions) {\n    if (x.kind === 'FragmentDefinition') {\n      fragments.push(x);\n      continue\n    }\n\n    if (x.kind === 'OperationDefinition') {\n      switch (x.operation) {\n        case 'query':\n          queries.push(x);\n          break;\n        case 'mutation':\n          mutations.push(x);\n          break;\n        case 'subscription':\n          subscriptions.push(x);\n          break;\n      }\n    }\n  }\n\n  invariant(\n    !fragments.length ||\n      (queries.length || mutations.length || subscriptions.length),\n    `Passing only a fragment to 'graphql' is not yet supported. ` +\n      `You must include a query, subscription or mutation as well`\n  );\n\n  invariant(\n    queries.length + mutations.length + subscriptions.length <= 1,\n    `react-apollo only supports a query, subscription, or a mutation per HOC. ` +\n      `${document} had ${queries.length} queries, ${subscriptions.length} ` +\n      `subscriptions and ${mutations.length} mutations. ` +\n      `You can use 'compose' to join multiple operation types to a component`\n  );\n\n  type = queries.length ? DocumentType.Query : DocumentType.Mutation;\n  if (!queries.length && !mutations.length) type = DocumentType.Subscription;\n\n  const definitions = queries.length\n    ? queries\n    : mutations.length\n    ? mutations\n    : subscriptions;\n\n  invariant(\n    definitions.length === 1,\n    `react-apollo only supports one definition per HOC. ${document} had ` +\n      `${definitions.length} definitions. ` +\n      `You can use 'compose' to join multiple operation types to a component`\n  );\n\n  const definition = definitions[0] as OperationDefinitionNode;\n  variables = definition.variableDefinitions || [];\n\n  if (definition.name && definition.name.kind === 'Name') {\n    name = definition.name.value;\n  } else {\n    name = 'data'; // fallback to using data if no name\n  }\n\n  const payload = { name, type, variables };\n  cache.set(document, payload);\n  return payload;\n}\n\nexport function verifyDocumentType(document: DocumentNode, type: DocumentType) {\n  const operation = parser(document);\n  const requiredOperationName = operationName(type);\n  const usedOperationName = operationName(operation.type);\n  invariant(\n    operation.type === type,\n    `Running a ${requiredOperationName} requires a graphql ` +\n      `${requiredOperationName}, but a ${usedOperationName} was used instead.`\n  );\n}\n\n", "import { useCallback, useEffect, useRef, useState } from 'react';\nimport { DocumentNode } from 'graphql';\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\nimport {\n  MutationFunctionOptions,\n  MutationHookOptions,\n  MutationResult,\n  MutationTuple,\n} from '../types/types';\n\nimport {\n  ApolloCache,\n  DefaultContext,\n  mergeOptions,\n  OperationVariables,\n} from '../../core';\nimport { equal } from '@wry/equality';\nimport { DocumentType, verifyDocumentType } from '../parser';\nimport { ApolloError } from '../../errors';\nimport { useApolloClient } from './useApolloClient';\n\nexport function useMutation<\n  TData = any,\n  TVariables = OperationVariables,\n  TContext = DefaultContext,\n  TCache extends ApolloCache<any> = ApolloCache<any>,\n>(\n  mutation: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: MutationHookOptions<TData, TVariables, TContext>,\n): MutationTuple<TData, TVariables, TContext, TCache> {\n  const client = useApolloClient(options?.client);\n  verifyDocumentType(mutation, DocumentType.Mutation);\n  const [result, setResult] = useState<Omit<MutationResult, 'reset'>>({\n    called: false,\n    loading: false,\n    client,\n  });\n\n  const ref = useRef({\n    result,\n    mutationId: 0,\n    isMounted: true,\n    client,\n    mutation,\n    options,\n  });\n\n  // TODO: Trying to assign these in a useEffect or useLayoutEffect breaks\n  // higher-order components.\n  {\n    Object.assign(ref.current, { client, options, mutation });\n  }\n\n  const execute = useCallback((\n    executeOptions: MutationFunctionOptions<\n      TData,\n      TVariables,\n      TContext,\n      TCache\n    > = {}\n  ) => {\n    const {client, options, mutation} = ref.current;\n    const baseOptions = { ...options, mutation };\n    if (!ref.current.result.loading && !baseOptions.ignoreResults) {\n      setResult(ref.current.result = {\n        loading: true,\n        error: void 0,\n        data: void 0,\n        called: true,\n        client,\n      });\n    }\n\n    const mutationId = ++ref.current.mutationId;\n    const clientOptions = mergeOptions(\n      baseOptions,\n      executeOptions as any,\n    );\n\n    return client.mutate(clientOptions).then((response) => {\n      const { data, errors } = response;\n      const error =\n        errors && errors.length > 0\n          ? new ApolloError({ graphQLErrors: errors })\n          : void 0;\n\n      if (\n        mutationId === ref.current.mutationId &&\n        !clientOptions.ignoreResults\n      ) {\n        const result = {\n          called: true,\n          loading: false,\n          data,\n          error,\n          client,\n        };\n\n        if (ref.current.isMounted && !equal(ref.current.result, result)) {\n          setResult(ref.current.result = result);\n        }\n      }\n\n      ref.current.options?.onCompleted?.(response.data!);\n      executeOptions.onCompleted?.(response.data!);\n      return response;\n    }).catch((error) => {\n      if (\n        mutationId === ref.current.mutationId &&\n        ref.current.isMounted\n      ) {\n        const result = {\n          loading: false,\n          error,\n          data: void 0,\n          called: true,\n          client,\n        };\n\n        if (!equal(ref.current.result, result)) {\n          setResult(ref.current.result = result);\n        }\n      }\n\n      if (ref.current.options?.onError || clientOptions.onError) {\n        ref.current.options?.onError?.(error);\n        executeOptions.onError?.(error);\n        // TODO(brian): why are we returning this here???\n        return { data: void 0, errors: error };\n      }\n\n      throw error;\n    });\n  }, []);\n\n  const reset = useCallback(() => {\n    setResult({ called: false, loading: false, client });\n  }, []);\n\n  useEffect(() => {\n    ref.current.isMounted = true;\n\n    return () => {\n      ref.current.isMounted = false;\n    };\n  }, []);\n\n  return [execute, { reset, ...result }];\n}\n", "import '../../utilities/globals';\nimport { useState, useRef, useEffect } from 'react';\nimport { DocumentNode } from 'graphql';\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\nimport { equal } from '@wry/equality';\n\nimport { DocumentType, verifyDocumentType } from '../parser';\nimport {\n  SubscriptionHookOptions,\n  SubscriptionResult\n} from '../types/types';\nimport { OperationVariables } from '../../core';\nimport { useApolloClient } from './useApolloClient';\n\nexport function useSubscription<TData = any, TVariables = OperationVariables>(\n  subscription: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: SubscriptionHookOptions<TData, TVariables>,\n) {\n  const client = useApolloClient(options?.client);\n  verifyDocumentType(subscription, DocumentType.Subscription);\n  const [result, setResult] = useState<SubscriptionResult<TData>>({\n    loading: !options?.skip,\n    error: void 0,\n    data: void 0,\n    variables: options?.variables,\n  });\n\n  const [observable, setObservable] = useState(() => {\n    if (options?.skip) {\n      return null;\n    }\n\n    return client.subscribe({\n      query: subscription,\n      variables: options?.variables,\n      fetchPolicy: options?.fetchPolicy,\n      context: options?.context,\n    });\n  });\n\n  const canResetObservableRef = useRef(false);\n  useEffect(() => {\n    return () => {\n      canResetObservableRef.current = true;\n    };\n  }, []);\n\n  const ref = useRef({ client, subscription, options });\n  useEffect(() => {\n    let shouldResubscribe = options?.shouldResubscribe;\n    if (typeof shouldResubscribe === 'function') {\n      shouldResubscribe = !!shouldResubscribe(options!);\n    }\n\n    if (options?.skip) {\n      if (!options?.skip !== !ref.current.options?.skip || canResetObservableRef.current) {\n        setResult({\n          loading: false,\n          data: void 0,\n          error: void 0,\n          variables: options?.variables,\n        });\n        setObservable(null);\n        canResetObservableRef.current = false;\n      }\n    } else if (\n      (shouldResubscribe !== false &&\n        (client !== ref.current.client ||\n          subscription !== ref.current.subscription ||\n          options?.fetchPolicy !== ref.current.options?.fetchPolicy ||\n          !options?.skip !== !ref.current.options?.skip ||\n          !equal(options?.variables, ref.current.options?.variables))) ||\n      canResetObservableRef.current\n    ) {\n      setResult({\n        loading: true,\n        data: void 0,\n        error: void 0,\n        variables: options?.variables,\n      });\n      setObservable(client.subscribe({\n        query: subscription,\n        variables: options?.variables,\n        fetchPolicy: options?.fetchPolicy,\n        context: options?.context,\n      }));\n      canResetObservableRef.current = false;\n    }\n\n    Object.assign(ref.current, { client, subscription, options });\n  }, [client, subscription, options, canResetObservableRef.current]);\n\n  useEffect(() => {\n    if (!observable) {\n      return;\n    }\n\n    const subscription = observable.subscribe({\n      next(fetchResult) {\n        const result = {\n          loading: false,\n          // TODO: fetchResult.data can be null but SubscriptionResult.data\n          // expects TData | undefined only\n          data: fetchResult.data!,\n          error: void 0,\n          variables: options?.variables,\n        };\n        setResult(result);\n\n        ref.current.options?.onSubscriptionData?.({\n          client,\n          subscriptionData: result\n        });\n      },\n      error(error) {\n        setResult({\n          loading: false,\n          data: void 0,\n          error,\n          variables: options?.variables,\n        });\n      },\n      complete() {\n        ref.current.options?.onSubscriptionComplete?.();\n      },\n    });\n\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [observable]);\n\n  return result;\n}\n", "import { useEffect, useState } from 'react';\nimport { ReactiveVar } from '../../core';\n\nexport function useReactiveVar<T>(rv: ReactiveVar<T>): T {\n  const value = rv();\n\n  // We don't actually care what useState thinks the value of the variable\n  // is, so we take only the update function from the returned array.\n  const setValue = useState(value)[1];\n\n  // We subscribe to variable updates on initial mount and when the value has\n  // changed. This avoids a subtle bug in React.StrictMode where multiple\n  // listeners are added, leading to inconsistent updates.\n  useEffect(() => {\n    const probablySameValue = rv();\n    if (value !== probablySameValue) {\n      // If the value of rv has already changed, we don't need to listen for the\n      // next change, because we can report this change immediately.\n      setValue(probablySameValue);\n    } else {\n      return rv.onNextChange(setValue);\n    }\n  }, [value]);\n\n  return value;\n}\n"],
  "mappings": "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",
  "names": ["React", "React", "import_react", "import_react", "React", "DocumentType", "InternalState", "result", "eagerMethods", "key", "execute", "import_react", "execute", "_a", "client", "options", "mutation", "import_react", "_a", "_b", "subscription", "result", "import_react"]
}
